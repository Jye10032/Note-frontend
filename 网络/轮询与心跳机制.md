轮询就是指一遍一遍的查询，用于客户端向服务端发送请求，查询信息。
**长轮询和短轮询**

**短轮询**

短轮询就是客户端发送 http 请求，询问是否发生改变，（定时轮询）如果频率较高，会导致服务器压力过大，频率过低又会导致响应不及时。

**长轮询**

长轮询是指如果客户端向服务端发送请求，如果这时服务端没有数据发生更改，那么就 hold 住这个请求，等到发生改变或者过了指定的一段时间后再返回给客户端。
长轮询需要隔一段时间后再重新发起。

因为长轮询时依靠 TCP 协议，在应用层没有
长轮询不会一直占用线程池。
会分配几个线程用于长轮询的相关任务，而其余的部分正常工作。

**心跳机制**

心跳机制可以"保活"连接。
客户端每隔N秒向服务端发送一个心跳消息，服务端收到心跳消息后，回复同样的心跳消息给客户端。如果服务端或客户端在M秒（M>N）内都没有收到包括心跳消息在内的任何消息，即心跳超时，我们就认为目标TCP连接已经断开了。


**心跳的作用**

通知服务器，客户端存活状态，一旦服务器监测到在某段时间没有收到客户端发来的心跳包，服务器就会释放曾经为此客户端分配的所有资源，例如Socket连接

**心跳的实现方案**

方案一：服务器->客服端

服务器建立定时器，定时发送心跳包给到客户端，客户端收到心跳包后，立即发送心跳包给到服务器，服务器收到客户端发来的心跳包后确认客户端的连接可用，不执行释放socket相关的操作。如果服务器端没规定的时间间隔内没有收到客户端响应的心跳包，服务器端就认为客户端的连接不可用，执行释放socket相关的操作。有点是服务器端能够准确的掌握客户端是否在线，缺点是对服务器端性能要求较高。

方案二：客服端->服务器

客户端定时主动的发送心跳包给到服务器端，服务器端收到心跳包后对相关的socket进行加标识，然后服务器端发送响应心跳包给到客户端。客户端收到心跳包认为连接可用。如果服务器端超过一段时间没有收到心跳包，相关的socket的标识符回进行降权，直至失效，然后服务器端会释放这个socket相关的资源。这个对服务器的性能要求不那么高。


上面所说的服务端和客户端的心跳机制属于应用层，在 TCP 层和网络层也存在类似的心跳机制。

**TCP 层的心跳机制**

在 TCP 中存在一个 keep alive 选项，开启这个选项后， TCP 会在连接一段时间后发送空的 ACK 包来检测连接是否存在，但是他检测不到机器断电、网络拔出或防火墙断线等情况，因为在这些情况下 TCP 自身也无法继续进行了。

在 Linux 操作系统中，我们可以通过代码启用一个 socket 的心跳检测（即每隔一定时间间隔发送一个心跳检测包给对端）。

```
//on 是 1 表示打开 keepalive 选项，为 0 表示关闭，0 是默认值
int on = 1;
setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on));
```

这个选项默认发送心跳检测数据包的时间间隔是 7200 秒（2 小时）。


**网络层的心跳机制**

通过发送特殊的ICMP Echo Request（ping）数据包来检测主机的存活状态。